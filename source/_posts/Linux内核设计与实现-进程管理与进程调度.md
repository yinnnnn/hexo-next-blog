---
title: Linux内核设计与实现-进程管理与进程调度
date: 2017-01-15 11:15:04
categories: Linux内核
---
## 第三章：进程管理
**简单记录看书看到的一些和自己之前理解有出入的点，做个记录：**

- 进程号的最大值是多少，能否调整大小？
> 最大进程数，默认在`cat /proc/sys/kernel/pid_max` 32768（short int短整型的最大值），可直接修改提高

- fork()写时拷贝：只有在需要写入的时候，数据才会被复制。
- 线程在Linux中的实现，
> 从内核的角度来说，它并没有线程这个概念。Linux把所有的线程都当作进程来实现。

- 内核是如何组织管理进程列表的？
> 双向循环列表，why？进程本身是树状的，有继承关系，父进程、子进程、兄弟进程。

- 进程描述符的结构
> 大约1.7KB,代码492行，接近500行！！！主要包括：打开的文件，进程的地址空间，挂起的信号，进程状态，父进程，子进程

- 虚拟地址空间和物理地址空间的区别？
- 各种内存malloc区别？tcmalloc,kmalloc,malloc,jemalloc

## 第四章：进程调度
### 一、基础概念
#### 1. 多任务系统概念
多任务系统分为：非抢占式多任务和抢占式多任务。Linux提供了抢占式多任务模式。在此模式下，由调度程序来决定什么时候停止一个进程的运行。而非抢占式多任务模式则是只能由进程自己土洞停止运行，否则一直执行。    

#### 2. 进程调度策略
调度策略通常要在两个矛盾的目标总结寻找平衡感：进程响应速度（响应时间短）和最大系统利用率（高吞吐量）。

#### 3. 进程优先级
调度算法中最基本的一类就是基于优先级调度。优先级高的进程先运行，低的后运行。相同优先级轮转调度。   
Linux采用了两种不同的优先级范围：  
第一种是nice值，它的范围从`-20`到`+19`,默认值为0，越大优先级越低（nice可以理解为对其他进程的友好程度）。 
> 可以通过`ps -el `查看nice值  

第二种范围是实时优先级，其值是可配置的。默认情况下变化范围从0到99，越高进程优先级越高。

#### 4. 时间片概念
除了优先级，另外一个很重要的指标就是时间片。它标明进程在被抢占前所能持续运行的时间。调度策略必须规定一个默认的时间片，但这不是一件简单的事。   
时间片过长会导致系统对交互的响应表现欠佳，让人觉得系统无法并发执行应用程序；时间片太短会明显增大进程切换带来的处理器耗时，因为肯定会有相当一部分系统时间用在进程切换上，而这些进程能够用来运行的时间片却很短。

### 二、Unix系统中的进程调度
在讨论公平调度算法前，我们必须首先认识一下传统Unix系统的调度过程。现代进程调度器有两个通用的概念（上面提到的）：进程优先级和时间片。优先级以nice值形式输出给用户空间。  
优先级越高的进程赋予的时间片越多，可以简单理解一个优先级与时间片的映射，比如noce值为0（最高优先级）对应100ms的时间片，nice值为+20（最低优先级）对应5ms的时间片。每一个nice值对应一个时间片长度。  
但是，这种方式听起来简单也很好理解，但会引发很多反常问题:

1. 若要将nice值映射到时间片，就必然需要将nice单位值对于到处理器的绝对时间，但这样做将会导致经常切换无法最优进行。举例说明：  
   假设有两个可运行状态的进程，nice值分别为0（对应100ms）和+20（对应5ms），两个进程分别获得的20/21(100ms)的处理器时间，和1/21(5ms)的处理器时间。  
    另一种情况，如果是两个同等优先级的进程各自能获得一般的处理器时间，对于两个nice值为+20的每次能获得50%的处理器时间，即5ms。
相比刚才例子中105ms内进行一次上下文切换，想着则需要在10ms内继续进行两次上下文切换。**显然，我们看到这些时间片的分配方式并不是很理想：它们是给定nice值到时间片映射与进程运行优先级混合的共同作用结果。**
2. nice值与时间片映射关系合理性问题。假如nice值0和1，被分别映射到时间片100ms和95ms，它们的时间片几乎一样，假设18和19的nice值分别映射为10ms和5ms，那么前者相比后者获得了两倍的处理器时间！把进程的nice值减小1所带来的效果极大地取决于其nice初始值。

## 三、CFS公平调度

### 1. 概念

对于上述的问题，CFS采用的方式是对时间片分配方式进行根本性的重新设计：**完全摒弃时间片而是分配给进程一个处理器使用比重。**通俗来讲，废弃nice值对应时间片的映射，而是采用nice值权重来分配处理器时间。      
先看两个概念：   
- 目标延迟：权重的时间分母值，每个进程按其权重在目标延迟时间内的长短，比如目标延迟为20ms，则每个进程根据权重分配20ms中的时间；   
- 最小粒度：每个进程按权重分配后得到的时间片不能小于最小粒度，默认是1ms，就是每个进程最低也能获得1ms的时间片执行时间。  

### 2. 实现
CFS调度算法相关代码位于文件`kernel/sched_fair.c`中，核心关注四个组成部分：

#### 2.1 时间记账
所有的调度器都必须对进程运行时间做记账。  
CFS使用调度器实体结构（`struct_sched_entity`）来追踪进程运行记账：
```cpp
struct sched_entity{
    ...
    u64   vruntime;
    ...
}

```
`vruntime`变量存放进程的虚拟运行时间，该运行时间的计算是经过了所有可运行进程总数的标准化。虚拟时间是以ns为单位。

#### 2.2 进程调度
当CFS需要选择下一个运行进程时，它会挑一个具有最小vruntime的进程。这其实就是CFS调度算法的核心：**选择具有最小vruntime的任务。**   
CFS使用**红黑树**来组织可运行进程队列，并利用其迅速找到最小vruntime值的进程。（注：每个nice值维护一个红黑树）
红黑树相关维护操作：  
- 挑选下一个任务：选取待运行的下一个进程，是所有vruntime最小的那个，它对于的便是树中最左侧的叶子结点。
- 先树中加入进程：但进程变为可运行状态或者是通过fork()调用第一次创建时执行。
- 从书中删除进程：发生在进程堵塞或者终止时

#### 2.3 调度器入口
进程调度的主要入口是函数`schedule()`，该函数中唯一重要的事情是，它会调用`pick_next_task()`。`pick_next_task()`会以优先级为序，从高到低，依次检查每一个调度类，并且从最高优先级的调度器类中，选择最高优先级的进程：
> http://lxr.free-electrons.com/source/kernel/sched/core.c#L3259
```cpp
/*
* Pick up the highest-prio task:
*/
static inline struct task_struct *
pick_next_task(struct rq *rq, struct task_struct *prev, struct pin_cookie cookie)
{
	 const struct sched_class *class = &fair_sched_class;
	 struct task_struct *p;

	 /*
	  * Optimization: we know that if all tasks are in
	  * the fair class we can call that function directly:
	  */
	 if (likely(prev->sched_class == class &&
				rq->nr_running == rq->cfs.h_nr_running)) {
			 p = fair_sched_class.pick_next_task(rq, prev, cookie);
			 if (unlikely(p == RETRY_TASK))
					 goto again;

			 /* assumes fair_sched_class->next == idle_sched_class */
			 if (unlikely(!p))
					 p = idle_sched_class.pick_next_task(rq, prev, cookie);

			 return p;
	 }

again:
	 for_each_class(class) {
			 p = class->pick_next_task(rq, prev, cookie);
			 if (p) {
					 if (unlikely(p == RETRY_TASK))
							 goto again;
					 return p;
			 }
	 }

	 BUG(); /* the idle class will always have a runnable task */
 }

```

#### 2.4 睡眠和唤醒
休眠（被阻塞）的进程处于一个特殊的不可执行状态。  
进程休眠有多种原因，但肯定都是为了等待一些事件。事件可能是从文件I/O读更多数据，或者是某个硬件事件。
休眠通过等待队列进行处理。等待队列是由等待某些事件发生的进程组成的简单链表。
唤醒操作通过函数`wake_up`进行，它会唤醒指定的等待队列上的所有进程。


